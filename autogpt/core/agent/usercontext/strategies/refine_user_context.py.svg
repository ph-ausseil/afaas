from logging import Logger
import uuid
import enum
from autogpt.core.configuration import SystemConfiguration, UserConfigurable
from autogpt.core.planning.base import BasePromptStrategy, PromptStrategiesConfiguration
from autogpt.core.planning.schema import (
    LanguageModelClassification,
    LanguageModelPrompt,
)
from autogpt.core.planning.utils import json_loads, to_numbered_list,to_string_list
from autogpt.core.resource.model_providers import (
    LanguageModelFunction,
    LanguageModelMessage,
    MessageRole,
)

class RefineUserContextFunctionNames(str, enum.Enum) : 
    REFINE_REQUIREMENTS : str = 'refine_requirements'
    REQUEST_SECOND_CONFIRMATION : str  = 'request_second_confirmation'
    VALIDATE_GOAL : str  = 'validate_goal'

class RefineUserContextConfiguration(PromptStrategiesConfiguration):
    model_classification : LanguageModelClassification = LanguageModelClassification.FAST_MODEL_4K
    default_function_call : RefineUserContextFunctionNames = RefineUserContextFunctionNames.REFINE_REQUIREMENTS
    strategy_name : str = "refine_user_context"
    context_min_tokens  : int = 250
    context_max_tokens : int = 300


class RefineUserContextStrategy(BasePromptStrategy):

    default_configuration = RefineUserContextConfiguration()
    STRATEGY_NAME = "refine_user_context"
    CONTEXT_MIN_TOKENS=250
    CONTEXT_MAX_TOKENS=300

    SYSTEM_PROMPT_INIT = (
"## Instructions :\n\n"

"You are an AI running on {os_info}. Your are tasked with assisting a user in formulating user requirements through an iterative process:"
#"To achieve this task effectively, you are provided with a set of functions:\n{functions_list}.\n\n"

"""### Iterative Process Flow:
1. Step 1 **User Provides Requirements**: You will receive user's requirements, reformulate them, and generate questions to assist users in providing more information. 
2. Step 2 **User Answers Clarification Questions**: You will receive the reformulated user requirements from Step 1, questions from Step 1, and user responses. You will reformulate user requirements by merging the previous requirements with the answers.

**Loop Control**: Continue this iterative process until users express a willingness to finalize the process.

"""
"Use these functions at your disposal to guide your interactions and responses.\n\n"

"To ensure the user's requirements adhere to our standards, follow the **COCE Framework**:\n\n"
" - **Comprehensible**: Your AI needs to be able to understand the goal, even within its limited context window. Minimize ambiguity, and use specific terminologies or semantics that the AI can comprehend.\n"
" - **Outcome-driven**: Focus on the end results or macro-goals that the AI should achieve, rather than measurable micro-goals or the steps that need to be taken to get there.\n"
" - **Context-aware**: The goal should be aware of and clearly define the context in which the AI is expected to function. This is especially important if the AI has a limited understanding of the world or the domain in which it operates.\n"
" - **Explicitness**: The goal must explicitly state what the AI needs to do. There should be no hidden assumptions or implied requirements. Everything that the AI needs to know to complete the goal should be explicitly stated.\n\n"
"Your primary role is to assist the user in adhering to these principles and guide them through the process of formulating requirements that meet these criteria. Please use your capabilities to ensure that the user's goal aligns with these principles by generating questions that guide him closer to our expectations in term of user requirement expression. \n\n"

"""### Explicit Steps for Guidance:
1. **Utilize User's Input**: ALWAYS use the user's prior requirements and their recent responses to inform your responses.
2. **No Assumptions**: NEVER make assumptions. Always align with the user's original expressions.
3. **Adhere to COCE**: Your reformulations, questions, and interactions should aim to get the user's requirements to fit the COCE Framework.
4. **Use Functions**: You MUST use the provided functions in your interactions: {function_names}.

It's crucial to use the user's input, make no assumptions, align with COCE, and use the provided functions. Prioritize the user's input and remain faithful to the COCE principles."""
)

#     NEW_SYSTEM_PROMPT = ("###  User's Requirements:\n"
# #"So far the user have expressed this requirements :\n"
# "\"{user_response}\"\n\n"
# )
    NEW_SYSTEM_PROMPT = ''
    NEW_ASSISTANT_PROMPT = "What are your requirements ?\n"
    #NEW_USER_PROMPT = "These are my requirement : \"{user_response}\"\n"
    NEW_USER_PROMPT = "{user_response}"


#     REFINED_ONCE_SYSTEM_PROMPT = ("### User's Journey:\n"
# #"So far the user have expressed these requirements :\n"
# "\"{user_response}\"\n\n"
# "- **Your questions**:\n" 
# "{last_questions}\n"
# "- **User's Response**: \n"
# "{user_response}\n\n"
# )

#     REFINED_SYSTEM_PROMPT = ("### User's Journey:\n"
# #"So far the user have expressed these requirements :\n"
# "'{user_last_goal}'\n\n"
# "- **Your full history of Questions**:\n" 
# "'{questions_history_full}\n"
# "- **Your Last Questions**:\n" 
# "{last_questions}\n"
# "- **User's Last Response**:\n"
# "{user_response}\n\n"
# )


    #     REFINED_SYSTEM_PROMPT = ("### User's Journey:\n"
    # "So far the user have expressed these requirements :\n"
    # "'{user_last_goal}'\n")
    REFINED_SYSTEM_PROMPT = ''
    REFINED_USER_PROMPT_A =  "{user_last_goal}"
    REFINED_ASSISTANT_PROMPT = "{last_questions}"
    REFINED_USER_PROMPT_B = "{user_response}"

#     SYSTEM_PROMPT_FOOTER = ("Guide the user closer to a refined goal by referencing the above journey and adhering to the **COCE Framework**. Provide actionable insights and questions.\n\n"    
# "### Note:\n"
# "This is an iterative process. Your generated `reformulated_goal` will serve as the user's next goal and the questions will gather further details from the user.\n"
# )
    SYSTEM_PROMPT_FOOTER = ''
    
    # SYSTEM_PROMPT_NOTICE = "**IMPORTANT** : YOU MUST USE FUNCTIONS AT YOUR DISPOSAL"
    SYSTEM_PROMPT_NOTICE = ''
    



    FUNCTION_REFINE_USER_CONTEXT  = {
    "name": RefineUserContextFunctionNames.REFINE_REQUIREMENTS,
    "description": "This function refines and clarifies user requirements by reformulating them and generating pertinent questions to extract more detailed and explicit information from the user, all while adhering to the COCE Framework.",
    "parameters": {
        "type": "object",
        "properties": {
            "reformulated_goal": {
                "type": "string",
                "description": f"Users requirements as interpreted from their initial expressed requirements and their most recent answer, making sure it adheres to the COCE Framework and remains true to the user's intent. It should be formatted using Markdown and expressed in {CONTEXT_MIN_TOKENS} to {CONTEXT_MAX_TOKENS} words."
            },
            "questions": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "description": "One to five questions designed to extract more detailed and explicit information from the user, guiding them towards a clearer expression of their requirements while staying within the COCE Framework."
            }
        },
        "required": ["reformulated_goal", "questions"]
    }
}
    



    FUNCTION_REQUEST_SECOND_CONFIRMATION = {
    "name": RefineUserContextFunctionNames.REQUEST_SECOND_CONFIRMATION,
    "description": "Double-check the user's intent to end the iterative requirement refining process. It poses a simple yes/no question to ensure that the user truly wants to conclude refining and proceed to the validation step.",
    "parameters": {
        "type": "object",
        "properties": {
            "questions": {
                "type": "string",
                "description": "A question aimed at reconfirming the user's intention to finalize their requirements. The question should be phrased in a manner that lets the user easily signify continuation ('no') or conclusion ('yes') of the refining process."
            }
        },
        "required": ["questions"]
    }
}


    FUNCTION_VALIDATE_GOAL = {
    "name": RefineUserContextFunctionNames.VALIDATE_GOAL,
    "description": "Seals the iterative process of refining requirements. It gets activated when the user communicates satisfaction with the requirements, signaling readiness to finalize the current list of goals.",
    "parameters": {
        "type": "object",
        "properties": {
            "goal_list": {
                "type": "array",
                "items": {
                    "type": "string"
                },
                "description": "The curated list of user requirements that emerged from prior interactions. Each entry in the list stands for a distinct requirement or aim expressed by the user."
            }
        },
        "required": ["goal_list"]
    }
}


    def __init__(
        self,
        logger : Logger,
        model_classification: LanguageModelClassification,
        default_function_call : RefineUserContextFunctionNames ,
        strategy_name : str ,
        context_min_tokens  : int ,
        context_max_tokens : int,
    ):
        self._logger = logger
        self._model_classification = model_classification
        # NOTE : Make a Dictionary ?
        self.question_history_full : list[str] = []
        self._last_questions = []
        self._user_last_goal = ''
        self._count = 0

        
        Re =LanguageModelFunction(
            **RefineUserContextStrategy.FUNCTION_REFINE_USER_CONTEXT,
        )
        Se= LanguageModelFunction(
            **RefineUserContextStrategy.FUNCTION_REQUEST_SECOND_CONFIRMATION,
        )
        Va =LanguageModelFunction(
            **RefineUserContextStrategy.FUNCTION_VALIDATE_GOAL,
        )
        self._functions =  [Re,Se ,Va]



    def build_prompt(self, user_objective: str = "", force_quite = False, **kwargs) -> LanguageModelPrompt:
        #
        # STEP 1 : List all functions available
        #
        strategy_functions =  self.get_functions()
        
        #
        # Step 2 A : Build the Sytem Promp
        #

        # NEW 
        if self._count == 0 : 
            first_system_prompt = self.SYSTEM_PROMPT_INIT
            first_system_prompt += self.SYSTEM_PROMPT_FOOTER
            first_user_prompt = self.NEW_USER_PROMPT
        else : 
        # REFINED 
            first_system_prompt = self.SYSTEM_PROMPT_INIT
            first_system_prompt += self.SYSTEM_PROMPT_FOOTER
            first_user_prompt = self.REFINED_USER_PROMPT_A
            first_assistant_prompt  = self.REFINED_ASSISTANT_PROMPT
            second_user_prompt= self.REFINED_USER_PROMPT_B

        first_system_message = LanguageModelMessage(
            role=MessageRole.SYSTEM,
            content=first_system_prompt.format(
                 os_info = kwargs['os_info'],
                 functions_list = to_numbered_list(self.get_functions_names()),
                 function_names = to_string_list(self.get_functions_names()),
                 user_last_goal = self._user_last_goal,
                 questions_history_full= to_numbered_list( [item['question'] for item in self.question_history_full]),
                 last_questions  = to_numbered_list([item['question'] for item in self._last_questions]),
                 user_response  = user_objective,
                )                 
            )

        #
        # Step 2 B : Build the Messages
        #
        if self._count == 0 : 
            first_user_message = LanguageModelMessage(
                role=MessageRole.USER,
                content=first_user_prompt.format(user_response = user_objective)
                )
            messages = [first_system_message, first_user_message]
        else : 
            first_user_message = LanguageModelMessage(
                role=MessageRole.USER,
                content=first_user_prompt.format(user_last_goal = self._user_last_goal)
                )
            first_assistant_message = LanguageModelMessage(
            role=MessageRole.ASSISTANT,
            content= first_assistant_prompt.format(last_questions  = to_numbered_list([item['question'] for item in self._last_questions]))    
            )
            second_user_message = LanguageModelMessage(
                role=MessageRole.USER,
                content=second_user_prompt.format(
                 user_response  = user_objective)
                )
            messages = [first_system_message, first_user_message, first_assistant_message, second_user_message]

        #
        # Step 4 : Hallucination safegard
        #
        function_call = 'auto'
        if self._count == 0 : 
           function_call =  RefineUserContextFunctionNames.REFINE_REQUIREMENTS
        elif force_quite == True :
            function_call =  RefineUserContextFunctionNames.VALIDATE_GOAL


        #
        # Step 5 : 
        #
        prompt = LanguageModelPrompt(
            messages=messages,
            functions=strategy_functions,
            function_call =  function_call, 
            default_function_call =  RefineUserContextFunctionNames.REFINE_REQUIREMENTS, 
            # TODO
            tokens_used=0,
        )
        #self._logger.debug('Executing prompt : ' + str(prompt))
        return prompt

    def parse_response_content(
        self,
        response_content: dict,
    ) -> dict:
        """Parse the actual text response from the objective model.

        Args:
            response_content: The raw response content from the objective model.

        Returns:
            The parsed response.

        """
        try : 
            parsed_response = json_loads(response_content["function_call"]['arguments'])
        except Exception :
            print('bad luck')


        #
        # Give id to questions
        # TODO : Type Questions in a Class ?
        #
        save_questions = False 
        if response_content["function_call"]["name"] == RefineUserContextFunctionNames.REFINE_REQUIREMENTS:

            questions_with_uuid = [{"id": "Q" + str(uuid.uuid4()), "question": q} for q in parsed_response["questions"]]
            save_questions = True 

            #
            # Saving the last goal
            #
            self._user_last_goal = parsed_response['reformulated_goal']
        elif  response_content["function_call"]["name"] == RefineUserContextFunctionNames.REQUEST_SECOND_CONFIRMATION :
            questions_with_uuid = [{"id": "Q" + str(uuid.uuid4()), "question":  parsed_response["questions"]}]
            save_questions = True 

        #
        # Saving the questions
        #
        if save_questions :
            self.question_history_full.extend(questions_with_uuid)
            self._last_questions = questions_with_uuid
            

        parsed_response['name'] = response_content["function_call"]["name"]
        self._logger.debug(parsed_response)
        self._count += 1 
        return parsed_response

